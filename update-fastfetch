#!/bin/sh
# SPDX-License-Identifier: MIT
# Copyright (c) 2026 Davoda1
#
# For the full license text, see the LICENSE file in this repository.
#
# update-fastfetch — Fastfetch updater for Debian/Ubuntu-like systems
# - Detects installed version (or uses 0.0.0 if not installed)
# - Auto-detects architecture and grabs the matching official .deb from the latest GitHub release
# - Downloads to /tmp and installs via dpkg
# - Supports optional --polyfilled flag (more portable build)
# - Colorful -h/--help and -v/--version flags (colors auto-disable when not a TTY)
#
# Requirements: curl, awk, grep, dpkg, sudo
# Source: https://github.com/fastfetch-cli/fastfetch/releases
#
# Exit codes:
#   0  success / already up-to-date
#   1  missing dependency / fatal error

set -eu

SELF_VERSION="1.0.0"
REPO_SLUG="fastfetch-cli/fastfetch"
API_URL="https://api.github.com/repos/${REPO_SLUG}/releases/latest"

POLYFILLED=0
# ---------- Colors (auto-disable if not a TTY) ----------
if [ -t 1 ]; then
    BOLD="$(tput bold 2>/dev/null || printf '')"
    DIM="$(tput dim 2>/dev/null || printf '')"
    RESET="$(tput sgr0 2>/dev/null || printf '')"
    RED="$(tput setaf 1 2>/dev/null || printf '')"
    GREEN="$(tput setaf 2 2>/dev/null || printf '')"
    YELLOW="$(tput setaf 3 2>/dev/null || printf '')"
    BLUE="$(tput setaf 4 2>/dev/null || printf '')"
    MAGENTA="$(tput setaf 5 2>/dev/null || printf '')"
    CYAN="$(tput setaf 6 2>/dev/null || printf '')"
else
    BOLD=""; DIM=""; RESET=""; RED=""; GREEN=""; YELLOW=""; BLUE=""; MAGENTA=""; CYAN=""
fi

# ---------- Helpers ----------
need() { command -v "$1" >/dev/null 2>&1 || { printf "%sERROR:%s '%s' is required\n" "$RED" "$RESET" "$1" >&2; exit 1; }; }
say()  { printf "%s\n" "$*"; }
ok()   { printf "%s✔ %s %s\n" "$GREEN" "$RESET" "$*"; }
warn() { printf "%s!%s %s\n" "$YELLOW" "$RESET" "$*"; }
err()  { printf "%s✘ %s %s\n" "$RED" "$RESET" "$*" >&2; }

usage() {
    cat <<EOF
${BOLD}update-fastfetch${RESET} — ${DIM}official binary updater for Fastfetch (.deb)${RESET}

${BOLD}Usage:${RESET}
  ${YELLOW}update-fastfetch${RESET}              ${DIM}Check + update to latest release if newer${RESET}
  ${YELLOW}update-fastfetch${RESET} ${BLUE}--polyfilled${RESET} ${DIM}Install the polyfilled build (more portable)${RESET}
  ${YELLOW}update-fastfetch${RESET} ${BLUE}-h${RESET}|${BLUE}--help${RESET}    ${DIM}Show this help${RESET}
  ${YELLOW}update-fastfetch${RESET} ${BLUE}-v${RESET}|${BLUE}--version${RESET} ${DIM}Show script version${RESET}
  ${YELLOW}update-fastfetch${RESET} ${BLUE}--self-test${RESET}  ${DIM}Check dependencies + network endpoints and exit${RESET}

${BOLD}What it does:${RESET}
  • Detects your CPU architecture
  • Reads installed Fastfetch version (if present)
  • Queries GitHub for the latest release
  • If newer: downloads the matching .deb to /tmp and installs via dpkg

  • Optionally installs the ${BOLD}polyfilled${RESET} build (more portable)
${BOLD}Requirements:${RESET}
  curl, awk, grep, dpkg, sudo

${BOLD}Source:${RESET}
  ${CYAN}https://github.com/${REPO_SLUG}/releases${RESET}
EOF
}

# ---------- Args ----------
SELF_TEST=0
FLAG_COUNT=0

while [ $# -gt 0 ]; do
    case "$1" in
        -h|--help)
            FLAG_COUNT=$((FLAG_COUNT + 1))
            # Enforce: only one flag total
            if [ "$FLAG_COUNT" -gt 1 ]; then
                err "Multiple flags provided. Use only one of: --help, --version, --self-test, --polyfilled"
                exit 2
            fi
            usage
            exit 0
            ;;
        -v|--version)
            FLAG_COUNT=$((FLAG_COUNT + 1))
            if [ "$FLAG_COUNT" -gt 1 ]; then
                err "Multiple flags provided. Use only one of: --help, --version, --self-test, --polyfilled"
                exit 2
            fi
            printf "update-fastfetch %s\n" "$SELF_VERSION"
            exit 0
            ;;
        --polyfilled)
            FLAG_COUNT=$((FLAG_COUNT + 1))
            if [ "$FLAG_COUNT" -gt 1 ]; then
                err "Multiple flags provided. Use only one of: --help, --version, --self-test, --polyfilled"
                exit 2
            fi
            POLYFILLED=1
            ;;
        --self-test)
            FLAG_COUNT=$((FLAG_COUNT + 1))
            if [ "$FLAG_COUNT" -gt 1 ]; then
                err "Multiple flags provided. Use only one of: --help, --version, --self-test, --polyfilled"
                exit 2
            fi
            SELF_TEST=1
            ;;
        --)
            shift
            break
            ;;
        -*)
            err "Unknown option: $1"
            say "Try: update-fastfetch --help"
            exit 2
            ;;
        *)
            err "Unexpected argument: $1"
            say "This script does not accept positional arguments."
            say "Try: update-fastfetch --help"
            exit 2
            ;;
    esac
    shift
done


# ---------- Self-test ----------
# In self-test mode we do NOT fail fast: we want to report every check.
# We also avoid hard `need()` exits; instead we report missing tools as errors.
if [ "${SELF_TEST:-0}" -eq 1 ]; then
    say "${BOLD}Self-test:${RESET}"
    SELFTEST_FAIL=0

    check_tool() {
        _t="$1"
        if command -v "$_t" >/dev/null 2>&1; then
            ok "Tool: $_t"
            return 0
        fi
        err "Tool: $_t (missing)"
        SELFTEST_FAIL=1
        return 1
    }

    # ----- Tools / programs -----
    HAVE_CURL=0
    HAVE_AWK=0
    HAVE_GREP=0
    HAVE_DPKG=0
    HAVE_SUDO=0

    HAVE_SHA=0
    if check_tool curl; then HAVE_CURL=1; fi
    if check_tool awk; then HAVE_AWK=1; fi
    if check_tool grep; then HAVE_GREP=1; fi
    if check_tool dpkg; then HAVE_DPKG=1; fi

    if check_tool sha256sum; then HAVE_SHA=1; fi
    # Root-aware sudo requirement
    if command -v id >/dev/null 2>&1; then
        UID_NOW="$(id -u 2>/dev/null || echo 1)"
        if [ "$UID_NOW" -eq 0 ]; then
            ok "Privilege: running as root (sudo not required)"
            HAVE_SUDO=1
        else
            if check_tool sudo; then
                ok "Privilege: running as uid $UID_NOW (sudo available)"
                HAVE_SUDO=1
            else
                err "Privilege: running as uid $UID_NOW (sudo missing; install will fail)"
                SELFTEST_FAIL=1
            fi
        fi
    else
        warn "Tool: id (missing) — cannot detect root; assuming sudo is required"
        if check_tool sudo; then HAVE_SUDO=1; else SELFTEST_FAIL=1; fi
    fi

    # ----- Network checks (only if curl is available) -----
    if [ "$HAVE_CURL" -eq 1 ]; then
        GH_CODE="$(curl -sS -o /dev/null -w '%{http_code}' "https://github.com/" 2>/dev/null || echo "000")"
        if [ "$GH_CODE" = "200" ] || [ "$GH_CODE" = "301" ] || [ "$GH_CODE" = "302" ]; then
            ok "Network: github.com reachable (HTTP $GH_CODE)"
        else
            err "Network: github.com not reachable (HTTP $GH_CODE)"
            warn "If you are offline or behind a restrictive network, updates may fail."
            SELFTEST_FAIL=1
        fi

        API_CODE="$(curl -sS -o /dev/null -w '%{http_code}' "$API_URL" 2>/dev/null || echo "000")"
        if [ "$API_CODE" = "200" ]; then
            ok "GitHub API: reachable (HTTP $API_CODE)"
        else
            # Not fatal: the script can fall back to HTML redirect probing
            warn "GitHub API: not OK (HTTP $API_CODE) — script will fall back to HTML redirect probe."
        fi

        LATEST_CODE="$(curl -sS -o /dev/null -w '%{http_code}' "https://github.com/${REPO_SLUG}/releases/latest" 2>/dev/null || echo "000")"
        if [ "$LATEST_CODE" = "200" ] || [ "$LATEST_CODE" = "301" ] || [ "$LATEST_CODE" = "302" ]; then
            ok "Releases: latest endpoint reachable (HTTP $LATEST_CODE)"
        else
            err "Releases: latest endpoint not reachable (HTTP $LATEST_CODE)"
            SELFTEST_FAIL=1
        fi
    else
        warn "Skipping network checks because 'curl' is missing."
    fi

    if [ "$SELFTEST_FAIL" -ne 0 ]; then
        err "Self-test completed with errors."
        exit 1
    fi

    ok "Self-test passed."
    exit 0
fi

# ---------- Sanity checks ----------
need curl
need awk
need grep
need dpkg

need sha256sum
# Use sudo only when not already root
SUDO="sudo"
if [ "$(id -u 2>/dev/null || echo 1)" -eq 0 ]; then
    SUDO=""
else
    need sudo
fi

# ---------- Detect arch -> release asset token ----------

UNAME_M="$(uname -m 2>/dev/null || echo unknown)"
ARCH_TOKEN=""
case "$UNAME_M" in
    x86_64|amd64)   ARCH_TOKEN="amd64"   ;;
    aarch64|arm64)  ARCH_TOKEN="aarch64" ;;
    armv7l|armv7|armhf) ARCH_TOKEN="armv7l" ;;  # <-- fixed to match upstream asset name
    riscv64)        ARCH_TOKEN="riscv64" ;;
    i686|i386)      ARCH_TOKEN="i686"    ;;
    *)
        err "Unsupported or unknown arch: $UNAME_M"
        err "If your arch is supported upstream, please update the mapping in this script."
        exit 1
        ;;
esac
if [ "${POLYFILLED:-0}" -eq 1 ]; then
    ASSET_NAME_EXPECT="fastfetch-linux-${ARCH_TOKEN}-polyfilled.deb"
else
    ASSET_NAME_EXPECT="fastfetch-linux-${ARCH_TOKEN}.deb"
fi

# ---------- Determine installed version (or 0.0.0) ----------
CUR_VER="0.0.0"
if command -v fastfetch >/dev/null 2>&1; then
    # "fastfetch 2.53.0 (x86_64)" -> field 2
    CUR_VER="$(fastfetch --version 2>/dev/null | awk 'NR==1{print $2}')"
elif dpkg-query -W -f='${Status} ${Version}\n' fastfetch 2>/dev/null | grep -q '^install ok installed'; then
    CUR_VER="$(dpkg-query -W -f='${Version}\n' fastfetch 2>/dev/null | awk 'NR==1{print $1}')"
fi
[ -n "$CUR_VER" ] || CUR_VER="0.0.0"

say "${CYAN}Detected arch:${RESET} ${BOLD}$UNAME_M${RESET} → asset: ${BOLD}$ASSET_NAME_EXPECT${RESET}"
say "${CYAN}Installed:${RESET} ${BOLD}$CUR_VER${RESET}"

# ---------- Fetch latest release JSON (with fallback) ----------
API_TMP="$(mktemp "/tmp/update-fastfetch.api.XXXXXX")"
API_CODE="$(curl -sS -L -o "$API_TMP" -w '%{http_code}' "$API_URL" 2>/dev/null || echo "000")"
LATEST_JSON="$(cat "$API_TMP" 2>/dev/null || true)"
rm -f "$API_TMP"

# 200 OK is expected. 403/429 can happen due to rate limiting; other codes indicate network/proxy issues.
if [ "$API_CODE" != "200" ] || [ -z "$LATEST_JSON" ]; then
    if [ "$API_CODE" = "403" ] || [ "$API_CODE" = "429" ]; then
        warn "GitHub API unavailable (HTTP $API_CODE — likely rate-limited). Falling back to HTML redirect probe…"
    elif [ "$API_CODE" = "000" ]; then
        warn "GitHub API request failed (network error). Falling back to HTML redirect probe…"
    else
        warn "GitHub API returned HTTP $API_CODE. Falling back to HTML redirect probe…"
    fi
    # Resolve the real latest tag URL (no JSON). Example:
    # https://github.com/fastfetch-cli/fastfetch/releases/tag/2.53.0
    LATEST_HEAD_TMP="$(mktemp "/tmp/update-fastfetch.latest.XXXXXX")"
    LATEST_CODE="$(curl -sS -LI -o "$LATEST_HEAD_TMP" -w '%{http_code} %{url_effective}' "https://github.com/${REPO_SLUG}/releases/latest" 2>/dev/null || printf "000 ")"
    rm -f "$LATEST_HEAD_TMP"
    LATEST_HTTP="$(printf "%s" "$LATEST_CODE" | awk '{print $1}')"
    LATEST_URL="$(printf "%s" "$LATEST_CODE" | awk '{print $2}')"

    if [ "$LATEST_HTTP" != "200" ] && [ "$LATEST_HTTP" != "301" ] && [ "$LATEST_HTTP" != "302" ]; then
        warn "Latest release redirect probe returned HTTP $LATEST_HTTP (may still work via cached/redirected URL)."
    fi
    LATEST_VER="$(printf "%s" "$LATEST_URL" | awk -F'/tag/' 'NF>1{print $2}' | tr -d '\r\n')"
    [ -n "$LATEST_VER" ] || { err "Could not determine latest version from fallback."; exit 1; }
    say "${CYAN}Available:${RESET} ${BOLD}$LATEST_VER${RESET}"
    # We still need the asset URL; fetch the release JSON by explicit tag:
    LATEST_JSON="$(curl -fsSL "https://api.github.com/repos/${REPO_SLUG}/releases/tags/${LATEST_VER}" 2>/dev/null || true)"
    [ -n "$LATEST_JSON" ] || { err "Failed to retrieve release JSON for tag $LATEST_VER"; exit 1; }
else
    # Extract tag_name:"X.Y.Z"
    LATEST_VER="$(printf "%s" "$LATEST_JSON" | awk -F'"' '/"tag_name"[[:space:]]*:/ {print $4; exit}')"
    [ -n "$LATEST_VER" ] || { err "Could not parse latest version from GitHub API."; exit 1; }
    say "${CYAN}Available:${RESET} ${BOLD}$LATEST_VER${RESET}"
fi

# ---------- Compare versions ----------
if dpkg --compare-versions "$LATEST_VER" le "$CUR_VER"; then
    ok "Fastfetch is up-to-date."
    exit 0
fi
say "${BLUE}Updating Fastfetch from ${CUR_VER} → ${LATEST_VER}${RESET}"

# ---------- Find matching .deb asset URL from JSON ----------
# Prefer exact (non-polyfilled) match; grab its "browser_download_url"
ASSET_URL="$(printf "%s" "$LATEST_JSON" \
  | awk -v want="$ASSET_NAME_EXPECT" -F'"' '
      $2=="name" && $4==want {found=1}
      found && $2=="browser_download_url" {print $4; exit}
  ')"

# Fallback: construct the URL directly if JSON parsing didn’t yield a match
if [ -z "$ASSET_URL" ]; then
    ASSET_URL="https://github.com/${REPO_SLUG}/releases/download/${LATEST_VER}/${ASSET_NAME_EXPECT}"
fi

if [ -z "$ASSET_URL" ]; then
    err "Could not find asset '${ASSET_NAME_EXPECT}' in the latest release."
    warn "Available .deb assets in this release:"
    printf "%s\n" "$LATEST_JSON" | awk -F'"' '/"name"[[:space:]]*:/ && $4 ~ /\.deb$/ {print "  - " $4}' || true
    exit 1
fi
ok "Found asset: $ASSET_NAME_EXPECT"

# ---------- Download to /tmp ----------
TMP_DEB="$(mktemp "/tmp/${ASSET_NAME_EXPECT}.XXXXXX")"
say "Downloading: ${ASSET_URL}"
DL_CODE="$(curl -sS -fL -o "$TMP_DEB" -w '%{http_code}' "$ASSET_URL" 2>/dev/null || echo "000")"
if [ "$DL_CODE" != "200" ]; then
    warn "Download HTTP status: $DL_CODE"
fi
if [ ! -s "$TMP_DEB" ]; then
    rm -f "$TMP_DEB"
    err "Download failed or empty file."
    exit 1
fi
ok "Downloaded to $TMP_DEB"


# ---------- Verify SHA-256 (from upstream release notes) ----------
# We require a matching SHA-256 for the exact asset path, e.g.:
#   <hash>  fastfetch-linux-x86_64/fastfetch-linux-x86_64.deb
# or:
#   <hash>  fastfetch-linux-x86_64/fastfetch-linux-x86_64-polyfilled.deb
#
# If we cannot determine the expected hash, we abort rather than installing an unchecked file.
say "Verifying SHA-256…"
# We try both formats seen in upstream notes:
#   1) "<hash>  <filename>"
#   2) "<hash>  fastfetch-linux-<arch>/<filename>"
ASSET_PATH1="$ASSET_NAME_EXPECT"
ASSET_PATH2="fastfetch-linux-${ARCH_TOKEN}/${ASSET_NAME_EXPECT}"

REL_PAGE_URL="https://github.com/${REPO_SLUG}/releases/tag/${LATEST_VER}"
REL_HTML_TMP="$(mktemp "/tmp/update-fastfetch.rel.XXXXXX")"
REL_CODE="$(curl -sS -fL -o "$REL_HTML_TMP" -w '%{http_code}' "$REL_PAGE_URL" 2>/dev/null || echo "000")"
if [ "$REL_CODE" != "200" ]; then
    rm -f "$REL_HTML_TMP" "$TMP_DEB"
    err "Could not fetch release page for checksums (HTTP $REL_CODE)."
    exit 1
fi

# Strip HTML tags (best-effort) and extract the first 64-hex hash for our asset.
REL_TEXT="$(sed 's/<[^>]*>/ /g' "$REL_HTML_TMP")"
rm -f "$REL_HTML_TMP"

EXPECTED_SHA="$(printf "%s\n" "$REL_TEXT" | grep -F "$ASSET_PATH2" | grep -Eo '[0-9a-fA-F]{64}[[:space:]]+'"$ASSET_PATH2" | awk '{print $1}' | head -n1)"
if [ -z "${EXPECTED_SHA:-}" ]; then
    EXPECTED_SHA="$(printf "%s\n" "$REL_TEXT" | grep -F "$ASSET_PATH1" | grep -Eo '[0-9a-fA-F]{64}[[:space:]]+'"$ASSET_PATH1" | awk '{print $1}' | head -n1)"
fi

if [ -z "${EXPECTED_SHA:-}" ]; then
    rm -f "$TMP_DEB"
    err "Could not locate SHA-256 for asset in release notes."
    err "Tried: $ASSET_PATH2"
    err "       $ASSET_PATH1"
    err "Upstream release notes format may have changed; aborting install."
    exit 1
fi

ACTUAL_SHA="$(sha256sum "$TMP_DEB" | awk '{print $1}')"
if [ "$ACTUAL_SHA" != "$EXPECTED_SHA" ]; then
    rm -f "$TMP_DEB"
    err "SHA-256 mismatch for downloaded file."
    err "Expected: $EXPECTED_SHA"
    err "Actual:   $ACTUAL_SHA"
    exit 1
fi
ok "SHA-256 verified."

# ---------- Install ----------
say "Installing via dpkg…"
if ${SUDO:+$SUDO }dpkg -i "$TMP_DEB"; then
    ok "Installed Fastfetch ${LATEST_VER}"
else
    err "dpkg install failed. You may need to resolve dependencies (e.g., sudo apt -f install) and re-run."
    rm -f "$TMP_DEB"
    exit 1
fi

# ---------- Cleanup ----------
rm -f "$TMP_DEB"
say "${GREEN}Done.${RESET} ${DIM}(temporary file removed)${RESET}"
