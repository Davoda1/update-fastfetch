#!/bin/sh
# SPDX-License-Identifier: MIT
# Copyright (c) 2026 Davoda1
#
# For the full license text, see the LICENSE file in this repository.
#
# update-fastfetch — Fastfetch updater for Linux (.deb / .rpm)
# - Detects installed version (or uses 0.0.0 if not installed)
# - Auto-detects architecture and grabs the matching official package from the latest GitHub release
# - Downloads to /tmp and installs via the detected package stack
# - Supports optional --polyfilled flag (more portable build)
# - Colorful -h/--help and -v/--version flags (colors auto-disable when not a TTY)
#
# Package backends:
#   - Debian-like: prefers nala > apt > dpkg
#   - RPM-like:    prefers dnf > yum > zypper > rpm
#
# Requirements (varies by backend): curl, awk, grep, sha256sum, and one supported installer (above)
# Source: https://github.com/fastfetch-cli/fastfetch/releases
#
# Exit codes:
#   0  success / already up-to-date
#   1  missing dependency / fatal error
#   2  usage error

set -eu

# ---------- Pre-scan argv for color modifier ----------
# We need this before initializing color variables so that `--help` / `usage()` can be uncolored.
for _a in "$@"; do
    case "$_a" in
        --no-color) NO_COLOR=1 ;;
    esac
done

# ---------- Globals ----------
SELF_VERSION="1.1.0"
REPO_SLUG="fastfetch-cli/fastfetch"
API_URL="https://api.github.com/repos/${REPO_SLUG}/releases/latest"

# ---------- Colors (auto-disable if not a TTY or if NO_COLOR is set) ----------
if [ -t 1 ] && [ -z "${NO_COLOR:-}" ]; then
    BOLD="$(tput bold 2>/dev/null || printf '')"
    DIM="$(tput dim 2>/dev/null || printf '')"
    RESET="$(tput sgr0 2>/dev/null || printf '')"
    RED="$(tput setaf 1 2>/dev/null || printf '')"
    GREEN="$(tput setaf 2 2>/dev/null || printf '')"
    YELLOW="$(tput setaf 3 2>/dev/null || printf '')"
    BLUE="$(tput setaf 4 2>/dev/null || printf '')"
    MAGENTA="$(tput setaf 5 2>/dev/null || printf '')"
    CYAN="$(tput setaf 6 2>/dev/null || printf '')"
else
    BOLD=""; DIM=""; RESET=""; RED=""; GREEN=""; YELLOW=""; BLUE=""; MAGENTA=""; CYAN=""
fi

# ---------- Helpers ----------
need() { command -v "$1" >/dev/null 2>&1 || { printf "%sERROR:%s '%s' is required\n" "$RED" "$RESET" "$1" >&2; exit 1; }; }
say()  { printf "%s\n" "$*"; }
ok()   { printf "%s✔ %s %s\n" "$GREEN" "$RESET" "$*"; }
warn() { printf "%s!%s %s\n" "$YELLOW" "$RESET" "$*"; }
err()  { printf "%s✘ %s %s\n" "$RED" "$RESET" "$*" >&2; }

# Compare two dot-separated versions (numeric segments). Returns:
#   0 if equal
#   1 if $1 > $2
#   2 if $1 < $2
vercmp() {
    _a="${1:-0}"
    _b="${2:-0}"

    # Strip leading v (if any)
    case "$_a" in v*) _a="${_a#v}";; esac
    case "$_b" in v*) _b="${_b#v}";; esac

    # We only care about numeric dot-separated segments. Missing segments are treated as 0.
    # shellcheck disable=SC2039
    IFS=.
    # POSIX sh: "set --" is fine; restore IFS after.
    set -- $_a
    _a1="${1:-0}"; _a2="${2:-0}"; _a3="${3:-0}"; _a4="${4:-0}"
    set -- $_b
    _b1="${1:-0}"; _b2="${2:-0}"; _b3="${3:-0}"; _b4="${4:-0}"
    IFS=' '

    # Force numeric (awk is guaranteed later anyway, but keep pure sh here)
    # Compare in order
    for _seg in 1 2 3 4; do
        eval "_x=\$_a${_seg}; _y=\$_b${_seg}"
        # Empty -> 0
        [ -n "${_x:-}" ] || _x=0
        [ -n "${_y:-}" ] || _y=0

        # Numeric compare via awk to avoid undefined behavior with leading zeros / big ints
        _r="$(awk -v x="$_x" -v y="$_y" 'BEGIN{ if (x+0>y+0) print 1; else if (x+0<y+0) print 2; else print 0 }')"
        case "$_r" in
            1) return 1 ;;
            2) return 2 ;;
        esac
    done
    return 0
}

usage() {
    cat <<EOF
${BOLD}update-fastfetch${RESET} — ${DIM}official binary updater for Fastfetch (Linux .deb / .rpm)${RESET}

${BOLD}Usage:${RESET}
  ${YELLOW}update-fastfetch${RESET}              ${DIM}Check + update to latest release if newer${RESET}
  ${YELLOW}update-fastfetch${RESET} ${BLUE}--polyfilled${RESET} ${DIM}Install the polyfilled build (more portable)${RESET}
  ${YELLOW}update-fastfetch${RESET} ${BLUE}--self-test${RESET}  ${DIM}Check dependencies + network endpoints and exit${RESET}
  ${YELLOW}update-fastfetch${RESET} ${BLUE}--no-color${RESET}   ${DIM}Disable colored output (or set NO_COLOR env var)${RESET}
  ${YELLOW}update-fastfetch${RESET} ${BLUE}-h${RESET}|${BLUE}--help${RESET}    ${DIM}Show this help${RESET}
  ${YELLOW}update-fastfetch${RESET} ${BLUE}-v${RESET}|${BLUE}--version${RESET} ${DIM}Show script version${RESET}

${BOLD}What it does:${RESET}
  • Detects your CPU architecture
  • Detects a supported package stack (Debian-like or RPM-like)
  • Reads installed Fastfetch version (if present)
  • Queries GitHub for the latest release
  • If newer: downloads the matching package to /tmp and installs it
  • Optionally installs the ${BOLD}polyfilled${RESET} build (more portable)

${BOLD}Requirements:${RESET}
  curl, awk, grep, sha256sum, and one supported installer:
    Debian-like: nala OR apt OR dpkg
    RPM-like:    dnf OR yum OR zypper OR rpm

${BOLD}Source:${RESET}
  ${CYAN}https://github.com/${REPO_SLUG}/releases${RESET}
EOF
}

detect_backend() {
    # Linux only (for simplicity and safety)
    OS_NAME="$(uname -s 2>/dev/null || echo unknown)"
    if [ "$OS_NAME" != "Linux" ]; then
        err "Unsupported OS: $OS_NAME (this script supports Linux only)"
        exit 1
    fi

    PKG_KIND=""
    INSTALLER=""

    # Prefer explicit tools over /etc/os-release heuristics; this is robust in containers/minimal systems.
    if command -v dpkg >/dev/null 2>&1; then
        PKG_KIND="deb"
        if command -v nala >/dev/null 2>&1; then
            INSTALLER="nala"
        elif command -v apt >/dev/null 2>&1; then
            INSTALLER="apt"
        else
            INSTALLER="dpkg"
        fi
    elif command -v rpm >/dev/null 2>&1; then
        PKG_KIND="rpm"
        if command -v dnf >/dev/null 2>&1; then
            INSTALLER="dnf"
        elif command -v yum >/dev/null 2>&1; then
            INSTALLER="yum"
        elif command -v zypper >/dev/null 2>&1; then
            INSTALLER="zypper"
        else
            INSTALLER="rpm"
        fi
    else
        err "No supported package tooling found."
        err "Need either: dpkg (Debian-like) OR rpm (RPM-like)."
        exit 1
    fi

    export PKG_KIND INSTALLER
}

# ---------- Args ----------
SELF_TEST=0
FLAG_COUNT=0
POLYFILLED=0

while [ $# -gt 0 ]; do
    case "$1" in
        --no-color)
            NO_COLOR=1
            BOLD=""; DIM=""; RESET=""; RED=""; GREEN=""; YELLOW=""; BLUE=""; MAGENTA=""; CYAN=""
            ;;
        -h|--help)
            FLAG_COUNT=$((FLAG_COUNT + 1))
            # Enforce: only one flag total
            if [ "$FLAG_COUNT" -gt 1 ]; then
                err "Multiple flags provided. Use only one of: --help, --version, --self-test, --polyfilled, --no-color"
                exit 2
            fi
            usage
            exit 0
            ;;
        -v|--version)
            FLAG_COUNT=$((FLAG_COUNT + 1))
            if [ "$FLAG_COUNT" -gt 1 ]; then
                err "Multiple flags provided. Use only one of: --help, --version, --self-test, --polyfilled, --no-color"
                exit 2
            fi
            printf "update-fastfetch %s\n" "$SELF_VERSION"
            exit 0
            ;;
        --polyfilled)
            FLAG_COUNT=$((FLAG_COUNT + 1))
            if [ "$FLAG_COUNT" -gt 1 ]; then
                err "Multiple flags provided. Use only one of: --help, --version, --self-test, --polyfilled, --no-color"
                exit 2
            fi
            POLYFILLED=1
            ;;
        --self-test)
            FLAG_COUNT=$((FLAG_COUNT + 1))
            if [ "$FLAG_COUNT" -gt 1 ]; then
                err "Multiple flags provided. Use only one of: --help, --version, --self-test, --polyfilled, --no-color"
                exit 2
            fi
            SELF_TEST=1
            ;;
        --)
            shift
            break
            ;;
        -*)
            err "Unknown option: $1"
            say "Try: update-fastfetch --help"
            exit 2
            ;;
        *)
            err "Unexpected argument: $1"
            say "This script does not accept positional arguments."
            say "Try: update-fastfetch --help"
            exit 2
            ;;
    esac
    shift
done

# Detect OS + backend before self-test so requirements are backend-aware
detect_backend

# ---------- Self-test ----------
# In self-test mode we do NOT fail fast: we want to report every check.
# We also avoid hard `need()` exits; instead we report missing tools as errors.
if [ "${SELF_TEST:-0}" -eq 1 ]; then
    say "${BOLD}Self-test:${RESET}"
    SELFTEST_FAIL=0
    SELFTEST_WARN=0
    SELFTEST_OK=0

    ok()   { printf '%s✔  %s%s\n' "$GREEN" "$*" "$RESET"; SELFTEST_OK=$((SELFTEST_OK+1)); }
    warn() { printf '%s⚠  %s%s\n' "$YELLOW" "$*" "$RESET"; SELFTEST_WARN=$((SELFTEST_WARN+1)); }
    err()  { printf '%s✘  %s%s\n' "$RED" "$*" "$RESET"; SELFTEST_FAIL=1; }

    check_tool() {
        _t="$1"
        if command -v "$_t" >/dev/null 2>&1; then
            ok "Tool: $_t"
            return 0
        fi
        err "Tool: $_t (missing)"
        SELFTEST_FAIL=1
        return 1
    }

    say "${DIM}Backend:${RESET} ${BOLD}${PKG_KIND}${RESET} (${INSTALLER})"
    say ""

    # ----- Tools / programs -----
    HAVE_CURL=0
    HAVE_AWK=0
    HAVE_GREP=0
    HAVE_SHA=0
    HAVE_INSTALLER=0
    HAVE_SUDO=0

    if check_tool curl; then HAVE_CURL=1; fi
    if check_tool awk; then HAVE_AWK=1; fi
    if check_tool grep; then HAVE_GREP=1; fi
    if check_tool sha256sum; then HAVE_SHA=1; fi

    # Backend-specific requirements
    if [ "$PKG_KIND" = "deb" ]; then
        # Installer already selected in detect_backend(); check its presence (should be true)
        if check_tool "$INSTALLER"; then HAVE_INSTALLER=1; fi
        # dpkg-query / dpkg --compare-versions are used when available; they should exist on Debian-like systems
        if command -v dpkg >/dev/null 2>&1; then
            ok "Tool: dpkg (available)"
        else
            warn "Tool: dpkg (missing) — version compare may be less strict"
        fi
    else
        if check_tool "$INSTALLER"; then HAVE_INSTALLER=1; fi
        if command -v rpm >/dev/null 2>&1; then
            ok "Tool: rpm (available)"
        else
            err "Tool: rpm (missing) — required on RPM-like systems"
            SELFTEST_FAIL=1
        fi
    fi

    # Root-aware sudo requirement
    if command -v id >/dev/null 2>&1; then
        UID_NOW="$(id -u 2>/dev/null || echo 1)"
        if [ "$UID_NOW" -eq 0 ]; then
            ok "Privilege: running as root (sudo not required)"
            HAVE_SUDO=1
        else
            if check_tool sudo; then
                ok "Privilege: running as uid $UID_NOW (sudo available)"
                HAVE_SUDO=1
            else
                err "Privilege: running as uid $UID_NOW (sudo missing; install will fail)"
                SELFTEST_FAIL=1
            fi
        fi
    else
        warn "Tool: id (missing) — cannot detect root; assuming sudo is required"
        if check_tool sudo; then HAVE_SUDO=1; else SELFTEST_FAIL=1; fi
    fi

    # ----- Network checks (only if curl is available) -----
    if [ "$HAVE_CURL" -eq 1 ]; then
        GH_CODE="$(curl -sS -o /dev/null -w '%{http_code}' "https://github.com/" 2>/dev/null || echo "000")"
        if [ "$GH_CODE" = "200" ] || [ "$GH_CODE" = "301" ] || [ "$GH_CODE" = "302" ]; then
            ok "Network: github.com reachable (HTTP $GH_CODE)"
        else
            err "Network: github.com not reachable (HTTP $GH_CODE)"
            warn "If you are offline or behind a restrictive network, updates may fail."
            SELFTEST_FAIL=1
        fi

        API_CODE="$(curl -sS -o /dev/null -w '%{http_code}' "$API_URL" 2>/dev/null || echo "000")"
        if [ "$API_CODE" = "200" ]; then
            ok "GitHub API: reachable (HTTP $API_CODE)"
        else
            # Not fatal: the script can fall back to HTML redirect probing
            warn "GitHub API: not OK (HTTP $API_CODE) — script will fall back to HTML redirect probe."
        fi

        LATEST_CODE="$(curl -sS -o /dev/null -w '%{http_code}' "https://github.com/${REPO_SLUG}/releases/latest" 2>/dev/null || echo "000")"
        if [ "$LATEST_CODE" = "200" ] || [ "$LATEST_CODE" = "301" ] || [ "$LATEST_CODE" = "302" ]; then
            ok "Releases: latest endpoint reachable (HTTP $LATEST_CODE)"
        else
            err "Releases: latest endpoint not reachable (HTTP $LATEST_CODE)"
            SELFTEST_FAIL=1
        fi
    else
        warn "Skipping network checks because 'curl' is missing."
    fi

    say ""
    if [ "$SELFTEST_FAIL" -ne 0 ]; then
        say "${RED}Self-test summary:${RESET} ${SELFTEST_OK} OK, ${SELFTEST_WARN} WARN, ERRORS present"
        exit 1
    elif [ "$SELFTEST_WARN" -ne 0 ]; then
        say "${YELLOW}Self-test summary:${RESET} ${SELFTEST_OK} OK, ${SELFTEST_WARN} WARN, 0 ERR"
        exit 0
    else
        say "${GREEN}Self-test summary:${RESET} ${SELFTEST_OK} OK, 0 WARN, 0 ERR"
        exit 0
    fi
fi

# ---------- Sanity checks ----------
need curl
need awk
need grep
need sha256sum

# Backend-specific sanity checks
if [ "$PKG_KIND" = "deb" ]; then
    # Installer selection is already nala > apt > dpkg
    need "$INSTALLER"
    # dpkg is still useful for version compare; if missing, we fall back to vercmp()
    if command -v dpkg >/dev/null 2>&1; then :; else warn "dpkg not found; using internal version compare." ; fi
else
    need rpm
    need "$INSTALLER"
fi

# Use sudo only when not already root
SUDO="sudo"
if [ "$(id -u 2>/dev/null || echo 1)" -eq 0 ]; then
    SUDO=""
else
    need sudo
fi

# ---------- Detect arch -> release asset token ----------
UNAME_M="$(uname -m 2>/dev/null || echo unknown)"
ARCH_TOKEN=""
case "$UNAME_M" in
    x86_64|amd64)        ARCH_TOKEN="amd64"   ;;
    aarch64|arm64)       ARCH_TOKEN="aarch64" ;;
    armv7l|armv7|armhf)  ARCH_TOKEN="armv7l"  ;;  # matches upstream asset name
    armv6l|armv6)        ARCH_TOKEN="armv6l"  ;;
    riscv64)             ARCH_TOKEN="riscv64" ;;
    i686|i386)           ARCH_TOKEN="i686"    ;;
    ppc64le)             ARCH_TOKEN="ppc64le" ;;
    s390x)               ARCH_TOKEN="s390x"   ;;
    *)
        err "Unsupported or unknown arch: $UNAME_M"
        err "If your arch is supported upstream, please update the mapping in this script."
        exit 1
        ;;
esac

PKG_EXT="deb"
if [ "$PKG_KIND" = "rpm" ]; then
    PKG_EXT="rpm"
fi

if [ "${POLYFILLED:-0}" -eq 1 ]; then
    ASSET_NAME_EXPECT="fastfetch-linux-${ARCH_TOKEN}-polyfilled.${PKG_EXT}"
else
    ASSET_NAME_EXPECT="fastfetch-linux-${ARCH_TOKEN}.${PKG_EXT}"
fi

# ---------- Determine installed version (or 0.0.0) ----------
CUR_VER="0.0.0"
if command -v fastfetch >/dev/null 2>&1; then
    # "fastfetch 2.53.0 (x86_64)" -> field 2
    CUR_VER="$(fastfetch --version 2>/dev/null | awk 'NR==1{print $2}')"
elif [ "$PKG_KIND" = "deb" ]; then
    if command -v dpkg-query >/dev/null 2>&1 && dpkg-query -W -f='${Status} ${Version}\n' fastfetch 2>/dev/null | grep -q '^install ok installed'; then
        CUR_VER="$(dpkg-query -W -f='${Version}\n' fastfetch 2>/dev/null | awk 'NR==1{print $1}')"
    fi
else
    if rpm -q fastfetch >/dev/null 2>&1; then
        # VERSION-RELEASE -> take VERSION only
        CUR_VER="$(rpm -q --qf '%{VERSION}\n' fastfetch 2>/dev/null | awk 'NR==1{print $1}')"
    fi
fi
[ -n "$CUR_VER" ] || CUR_VER="0.0.0"

say "${CYAN}Backend:${RESET} ${BOLD}${PKG_KIND}${RESET} (${INSTALLER})"
say "${CYAN}Detected arch:${RESET} ${BOLD}$UNAME_M${RESET} → asset: ${BOLD}$ASSET_NAME_EXPECT${RESET}"
say "${CYAN}Installed:${RESET} ${BOLD}$CUR_VER${RESET}"

# ---------- Fetch latest release JSON (with fallback) ----------
API_TMP="$(mktemp "/tmp/update-fastfetch.api.XXXXXX")"
API_CODE="$(curl -sS -L -o "$API_TMP" -w '%{http_code}' "$API_URL" 2>/dev/null || echo "000")"
LATEST_JSON="$(cat "$API_TMP" 2>/dev/null || true)"
rm -f "$API_TMP"

# 200 OK is expected. 403/429 can happen due to rate limiting; other codes indicate network/proxy issues.
if [ "$API_CODE" != "200" ] || [ -z "$LATEST_JSON" ]; then
    if [ "$API_CODE" = "403" ] || [ "$API_CODE" = "429" ]; then
        warn "GitHub API unavailable (HTTP $API_CODE — likely rate-limited). Falling back to HTML redirect probe…"
    elif [ "$API_CODE" = "000" ]; then
        warn "GitHub API request failed (network error). Falling back to HTML redirect probe…"
    else
        warn "GitHub API returned HTTP $API_CODE. Falling back to HTML redirect probe…"
    fi
    # Resolve the real latest tag URL (no JSON). Example:
    # https://github.com/fastfetch-cli/fastfetch/releases/tag/2.53.0
    LATEST_HEAD_TMP="$(mktemp "/tmp/update-fastfetch.latest.XXXXXX")"
    LATEST_CODE="$(curl -sS -LI -o "$LATEST_HEAD_TMP" -w '%{http_code} %{url_effective}' "https://github.com/${REPO_SLUG}/releases/latest" 2>/dev/null || printf "000 ")"
    rm -f "$LATEST_HEAD_TMP"
    LATEST_HTTP="$(printf "%s" "$LATEST_CODE" | awk '{print $1}')"
    LATEST_URL="$(printf "%s" "$LATEST_CODE" | awk '{print $2}')"

    if [ "$LATEST_HTTP" != "200" ] && [ "$LATEST_HTTP" != "301" ] && [ "$LATEST_HTTP" != "302" ]; then
        warn "Latest release redirect probe returned HTTP $LATEST_HTTP (may still work via cached/redirected URL)."
    fi
    LATEST_VER="$(printf "%s" "$LATEST_URL" | awk -F'/tag/' 'NF>1{print $2}' | tr -d '\r\n')"
    [ -n "$LATEST_VER" ] || { err "Could not determine latest version from fallback."; exit 1; }
    say "${CYAN}Available:${RESET} ${BOLD}$LATEST_VER${RESET}"
    # We still need the asset URL; fetch the release JSON by explicit tag:
    LATEST_JSON="$(curl -fsSL "https://api.github.com/repos/${REPO_SLUG}/releases/tags/${LATEST_VER}" 2>/dev/null || true)"
    [ -n "$LATEST_JSON" ] || { err "Failed to retrieve release JSON for tag $LATEST_VER"; exit 1; }
else
    # Extract tag_name:"X.Y.Z"
    LATEST_VER="$(printf "%s" "$LATEST_JSON" | awk -F'"' '/"tag_name"[[:space:]]*:/ {print $4; exit}')"
    [ -n "$LATEST_VER" ] || { err "Could not parse latest version from GitHub API."; exit 1; }
    say "${CYAN}Available:${RESET} ${BOLD}$LATEST_VER${RESET}"
fi

# ---------- Compare versions ----------
UPTODATE=0
if [ "$PKG_KIND" = "deb" ] && command -v dpkg >/dev/null 2>&1; then
    if dpkg --compare-versions "$LATEST_VER" le "$CUR_VER"; then
        UPTODATE=1
    fi
else
    vercmp "$LATEST_VER" "$CUR_VER" || true
    _rc="$?"
    # vercmp: 2 means latest < current; 0 means equal
    if [ "$_rc" -eq 0 ] || [ "$_rc" -eq 2 ]; then
        UPTODATE=1
    fi
fi

if [ "$UPTODATE" -eq 1 ]; then
    ok "Fastfetch is up-to-date."
    exit 0
fi

say "${BLUE}Updating Fastfetch from ${CUR_VER} → ${LATEST_VER}${RESET}"

# ---------- Find matching asset URL from JSON ----------
# Prefer exact match; grab its "browser_download_url"
ASSET_URL="$(printf "%s" "$LATEST_JSON" \
  | awk -v want="$ASSET_NAME_EXPECT" -F'"' '
      $2=="name" && $4==want {found=1}
      found && $2=="browser_download_url" {print $4; exit}
  ')"

# Fallback: construct the URL directly if JSON parsing didn’t yield a match
if [ -z "$ASSET_URL" ]; then
    ASSET_URL="https://github.com/${REPO_SLUG}/releases/download/${LATEST_VER}/${ASSET_NAME_EXPECT}"
fi

if [ -z "$ASSET_URL" ]; then
    err "Could not find asset '${ASSET_NAME_EXPECT}' in the latest release."
    warn "Available assets in this release:"
    printf "%s\n" "$LATEST_JSON" | awk -F'"' '/"name"[[:space:]]*:/ {print "  - " $4}' || true
    exit 1
fi
ok "Found asset: $ASSET_NAME_EXPECT"

# ---------- Download to /tmp ----------
TMP_PKG="$(mktemp "/tmp/${ASSET_NAME_EXPECT}.XXXXXX")"
say "Downloading: ${ASSET_URL}"
DL_CODE="$(curl -sS -fL -o "$TMP_PKG" -w '%{http_code}' "$ASSET_URL" 2>/dev/null || echo "000")"
if [ "$DL_CODE" != "200" ]; then
    warn "Download HTTP status: $DL_CODE"
fi
if [ ! -s "$TMP_PKG" ]; then
    rm -f "$TMP_PKG"
    err "Download failed or empty file."
    exit 1
fi
ok "Downloaded to $TMP_PKG"

# ---------- Verify SHA-256 (from upstream release notes) ----------
# We require a matching SHA-256 for the exact asset path, e.g.:
#   <hash>  fastfetch-linux-amd64/fastfetch-linux-amd64.deb
#   <hash>  fastfetch-linux-amd64/fastfetch-linux-amd64.rpm
#
# If we cannot determine the expected hash, we abort rather than installing an unchecked file.
say "Verifying SHA-256…"
ASSET_PATH1="$ASSET_NAME_EXPECT"
ASSET_PATH2="fastfetch-linux-${ARCH_TOKEN}/${ASSET_NAME_EXPECT}"

REL_PAGE_URL="https://github.com/${REPO_SLUG}/releases/tag/${LATEST_VER}"
REL_HTML_TMP="$(mktemp "/tmp/update-fastfetch.rel.XXXXXX")"
REL_CODE="$(curl -sS -fL -o "$REL_HTML_TMP" -w '%{http_code}' "$REL_PAGE_URL" 2>/dev/null || echo "000")"
if [ "$REL_CODE" != "200" ]; then
    rm -f "$REL_HTML_TMP" "$TMP_PKG"
    err "Could not fetch release page for checksums (HTTP $REL_CODE)."
    exit 1
fi

# Strip HTML tags (best-effort) and extract the first 64-hex hash for our asset.
REL_TEXT="$(sed 's/<[^>]*>/ /g' "$REL_HTML_TMP")"
rm -f "$REL_HTML_TMP"

EXPECTED_SHA="$(printf "%s\n" "$REL_TEXT" | grep -F "$ASSET_PATH2" | grep -Eo '[0-9a-fA-F]{64}[[:space:]]+'"$ASSET_PATH2" | awk '{print $1}' | head -n1)"
if [ -z "${EXPECTED_SHA:-}" ]; then
    EXPECTED_SHA="$(printf "%s\n" "$REL_TEXT" | grep -F "$ASSET_PATH1" | grep -Eo '[0-9a-fA-F]{64}[[:space:]]+'"$ASSET_PATH1" | awk '{print $1}' | head -n1)"
fi

if [ -z "${EXPECTED_SHA:-}" ]; then
    rm -f "$TMP_PKG"
    err "Could not locate SHA-256 for asset in release notes."
    err "Tried: $ASSET_PATH2"
    err "       $ASSET_PATH1"
    err "Upstream release notes format may have changed; aborting install."
    exit 1
fi

ACTUAL_SHA="$(sha256sum "$TMP_PKG" | awk '{print $1}')"
if [ "$ACTUAL_SHA" != "$EXPECTED_SHA" ]; then
    rm -f "$TMP_PKG"
    err "SHA-256 mismatch for downloaded file."
    err "Expected: $EXPECTED_SHA"
    err "Actual:   $ACTUAL_SHA"
    exit 1
fi
ok "SHA-256 verified."

# ---------- Install ----------
say "Installing (${PKG_KIND})…"
if [ "$PKG_KIND" = "deb" ]; then
    case "$INSTALLER" in
        nala)
            # nala can install local .deb and resolves deps (recommended)
            if ${SUDO:+$SUDO }nala install -y "$TMP_PKG"; then
                ok "Installed Fastfetch ${LATEST_VER}"
            else
                err "nala install failed."
                rm -f "$TMP_PKG"
                exit 1
            fi
            ;;
        apt)
            # apt can install local .deb and resolves deps (recommended)
            if ${SUDO:+$SUDO }apt install -y "$TMP_PKG"; then
                ok "Installed Fastfetch ${LATEST_VER}"
            else
                err "apt install failed."
                rm -f "$TMP_PKG"
                exit 1
            fi
            ;;
        dpkg)
            if ${SUDO:+$SUDO }dpkg -i "$TMP_PKG"; then
                ok "Installed Fastfetch ${LATEST_VER}"
            else
                err "dpkg install failed. You may need to resolve dependencies (e.g., sudo apt -f install) and re-run."
                rm -f "$TMP_PKG"
                exit 1
            fi
            ;;
        *)
            err "Internal error: unknown Debian installer '$INSTALLER'"
            rm -f "$TMP_PKG"
            exit 1
            ;;
    esac
else
    case "$INSTALLER" in
        dnf)
            if ${SUDO:+$SUDO }dnf install -y "$TMP_PKG"; then
                ok "Installed Fastfetch ${LATEST_VER}"
            else
                err "dnf install failed."
                rm -f "$TMP_PKG"
                exit 1
            fi
            ;;
        yum)
            if ${SUDO:+$SUDO }yum install -y "$TMP_PKG"; then
                ok "Installed Fastfetch ${LATEST_VER}"
            else
                err "yum install failed."
                rm -f "$TMP_PKG"
                exit 1
            fi
            ;;
        zypper)
            # zypper supports installing local rpm files via "install ./file.rpm"
            if ${SUDO:+$SUDO }zypper --non-interactive install "$TMP_PKG"; then
                ok "Installed Fastfetch ${LATEST_VER}"
            else
                err "zypper install failed."
                rm -f "$TMP_PKG"
                exit 1
            fi
            ;;
        rpm)
            # rpm alone doesn't resolve dependencies; we keep it as last-resort.
            if ${SUDO:+$SUDO }rpm -Uvh --replacepkgs "$TMP_PKG"; then
                ok "Installed Fastfetch ${LATEST_VER}"
            else
                err "rpm install failed. Consider installing with dnf/yum/zypper for dependency resolution."
                rm -f "$TMP_PKG"
                exit 1
            fi
            ;;
        *)
            err "Internal error: unknown RPM installer '$INSTALLER'"
            rm -f "$TMP_PKG"
            exit 1
            ;;
    esac
fi

# ---------- Cleanup ----------
rm -f "$TMP_PKG"
say "${GREEN}Done.${RESET} ${DIM}(temporary file removed)${RESET}"
